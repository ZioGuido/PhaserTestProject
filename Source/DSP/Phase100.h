/*
 * Code generated by GSi Phaser Factory
 * www.GenuineSoundware.com
 *
 * 6 Nov 2022 6:23:06pm
 */

#include <cmath>

class CPhaser
{
public:
	CPhaser(float sampleRate)
	{
		LFO = new LowFreqOsc(sampleRate);
		HiPass = new HiPassFilter(sampleRate, 20);
		LoPass = new LoPassFilter(sampleRate, 0.5445);

		setRate(0.648);
		setDepth(0.150);
	}
	~CPhaser()
	{
		delete LFO;
		delete HiPass;
		delete LoPass;
	}

	void toggleOnOff(bool isOn)
	{
		bypass = !isOn;
	}
	void setRate(float freq)
	{
		LFO->setRate(freq);
	}
	void setDepth(float d)
	{
		depth = d * 2.f;
	}

	void Process(float& mono)
	{
		if (bypass) return;

		auto mod = LoPass->Process(clip11(LFO->Process() * depth + 0.68)); // Remove + sign if offset is negative

		mono *= 0.765; // Remove this line if mutiplier == 1.0
		float out = HiPass->Process(mono) - feedback; // Remove feedback sum if feedback amount (below) == 0
		for (auto& s : apf)
		{
			s.gain = mod;
			out = s.Process(out);
		}

		feedback = out * 0.657; // Remove this line if multiplier (feedback amount) == 0
		mono -= out * 1.000; // Remove last multiplication if mutiplier == 1.0
	}


private:

	struct APF
	{
		float Process(float in)
		{
			float ao = ps - in * gain;
			ps = ao * gain + in;
			return ao;
		}
		float ps = 0.f;
		float gain = 0.5f;
	};

	struct HiPassFilter
	{
		HiPassFilter(float sampleRate, float f)
		{
			filter_const = 2.f * sinf(3.1415926535f * f / sampleRate);
		}
		float Process(float in)
		{
			float out = in - ps;
			ps -= (ps - in) * filter_const;
			return out;
		}
		float ps = 0.f, filter_const;
	};

	struct LoPassFilter
	{
		LoPassFilter(float sampleRate, float f)
		{
			b1 = exp(-2.f * 3.1415926535f * f / sampleRate);
			a0 = 1.f - b1;
		}
		float Process(float input)
		{
			ps = a0 * input + b1 * ps;
			return ps;
		}
		float ps = 0.f, a0, b1;
	};

	class LowFreqOsc
	{
	public:
		LowFreqOsc(float sampleRate)
		{
			phase = 0.f;
			srRecip = 1.f / sampleRate;
		}
		void setRate(float frequency)
		{
			delta = srRecip * frequency;
		}
		float Process()
		{
			phase += delta;
			if (phase > 0.5f) phase -= 1.f;
			return abs(phase) * 2.f;
		}

	private:
		float srRecip, phase, delta;
	};

	float clip11(float value)
	{
		return value < -1.f ? -1.f : (1.f < value ? 1.f : value);
	}


	APF apf[8];
	HiPassFilter* HiPass;
	LoPassFilter* LoPass;
	LowFreqOsc* LFO;
	bool bypass = false;
	float depth = 0.f;
	float feedback = 0.f;
};
